{"ast":null,"code":"import { Extension } from '@tiptap/core';\nimport { Plugin, PluginKey } from '@tiptap/pm/state';\n\n/**\n * This extension allows you to count the characters and words of your document.\n * @see https://tiptap.dev/api/extensions/character-count\n */\nconst CharacterCount = Extension.create({\n  name: 'characterCount',\n  addOptions() {\n    return {\n      limit: null,\n      mode: 'textSize',\n      textCounter: text => text.length,\n      wordCounter: text => text.split(' ').filter(word => word !== '').length\n    };\n  },\n  addStorage() {\n    return {\n      characters: () => 0,\n      words: () => 0\n    };\n  },\n  onBeforeCreate() {\n    this.storage.characters = options => {\n      const node = (options === null || options === void 0 ? void 0 : options.node) || this.editor.state.doc;\n      const mode = (options === null || options === void 0 ? void 0 : options.mode) || this.options.mode;\n      if (mode === 'textSize') {\n        const text = node.textBetween(0, node.content.size, undefined, ' ');\n        return this.options.textCounter(text);\n      }\n      return node.nodeSize;\n    };\n    this.storage.words = options => {\n      const node = (options === null || options === void 0 ? void 0 : options.node) || this.editor.state.doc;\n      const text = node.textBetween(0, node.content.size, ' ', ' ');\n      return this.options.wordCounter(text);\n    };\n  },\n  addProseMirrorPlugins() {\n    let initialEvaluationDone = false;\n    return [new Plugin({\n      key: new PluginKey('characterCount'),\n      appendTransaction: (transactions, oldState, newState) => {\n        if (initialEvaluationDone) {\n          return;\n        }\n        const limit = this.options.limit;\n        if (limit === null || limit === undefined || limit === 0) {\n          initialEvaluationDone = true;\n          return;\n        }\n        const initialContentSize = this.storage.characters({\n          node: newState.doc\n        });\n        if (initialContentSize > limit) {\n          const over = initialContentSize - limit;\n          const from = 0;\n          const to = over;\n          console.warn(`[CharacterCount] Initial content exceeded limit of ${limit} characters. Content was automatically trimmed.`);\n          const tr = newState.tr.deleteRange(from, to);\n          initialEvaluationDone = true;\n          return tr;\n        }\n        initialEvaluationDone = true;\n      },\n      filterTransaction: (transaction, state) => {\n        const limit = this.options.limit;\n        // Nothing has changed or no limit is defined. Ignore it.\n        if (!transaction.docChanged || limit === 0 || limit === null || limit === undefined) {\n          return true;\n        }\n        const oldSize = this.storage.characters({\n          node: state.doc\n        });\n        const newSize = this.storage.characters({\n          node: transaction.doc\n        });\n        // Everything is in the limit. Good.\n        if (newSize <= limit) {\n          return true;\n        }\n        // The limit has already been exceeded but will be reduced.\n        if (oldSize > limit && newSize > limit && newSize <= oldSize) {\n          return true;\n        }\n        // The limit has already been exceeded and will be increased further.\n        if (oldSize > limit && newSize > limit && newSize > oldSize) {\n          return false;\n        }\n        const isPaste = transaction.getMeta('paste');\n        // Block all exceeding transactions that were not pasted.\n        if (!isPaste) {\n          return false;\n        }\n        // For pasted content, we try to remove the exceeding content.\n        const pos = transaction.selection.$head.pos;\n        const over = newSize - limit;\n        const from = pos - over;\n        const to = pos;\n        // It’s probably a bad idea to mutate transactions within `filterTransaction`\n        // but for now this is working fine.\n        transaction.deleteRange(from, to);\n        // In some situations, the limit will continue to be exceeded after trimming.\n        // This happens e.g. when truncating within a complex node (e.g. table)\n        // and ProseMirror has to close this node again.\n        // If this is the case, we prevent the transaction completely.\n        const updatedSize = this.storage.characters({\n          node: transaction.doc\n        });\n        if (updatedSize > limit) {\n          return false;\n        }\n        return true;\n      }\n    })];\n  }\n});\nexport { CharacterCount, CharacterCount as default };","map":{"version":3,"names":["CharacterCount","Extension","create","name","addOptions","limit","mode","textCounter","text","length","wordCounter","split","filter","word","addStorage","characters","words","onBeforeCreate","storage","options","node","editor","state","doc","textBetween","content","size","undefined","nodeSize","addProseMirrorPlugins","initialEvaluationDone","Plugin","key","PluginKey","appendTransaction","transactions","oldState","newState","initialContentSize","over","from","to","console","warn","tr","deleteRange","filterTransaction","transaction","docChanged","oldSize","newSize","isPaste","getMeta","pos","selection","$head","updatedSize"],"sources":["C:\\Users\\shivn\\OneDrive\\Desktop\\News Mania\\frontend\\node_modules\\@tiptap\\extension-character-count\\src\\character-count.ts"],"sourcesContent":["import { Extension } from '@tiptap/core'\nimport { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\n\nexport interface CharacterCountOptions {\n  /**\n   * The maximum number of characters that should be allowed. Defaults to `0`.\n   * @default null\n   * @example 180\n   */\n  limit: number | null | undefined\n  /**\n   * The mode by which the size is calculated. If set to `textSize`, the textContent of the document is used.\n   * If set to `nodeSize`, the nodeSize of the document is used.\n   * @default 'textSize'\n   * @example 'textSize'\n   */\n  mode: 'textSize' | 'nodeSize'\n  /**\n * The text counter function to use. Defaults to a simple character count.\n * @default (text) => text.length\n * @example (text) => [...new Intl.Segmenter().segment(text)].length\n */\n  textCounter: (text: string) => number\n  /**\n   * The word counter function to use. Defaults to a simple word count.\n   * @default (text) => text.split(' ').filter(word => word !== '').length\n   * @example (text) => text.split(/\\s+/).filter(word => word !== '').length\n   */\n  wordCounter: (text: string) => number\n}\n\nexport interface CharacterCountStorage {\n  /**\n   * Get the number of characters for the current document.\n   * @param options The options for the character count. (optional)\n   * @param options.node The node to get the characters from. Defaults to the current document.\n   * @param options.mode The mode by which the size is calculated. If set to `textSize`, the textContent of the document is used.\n   */\n  characters: (options?: { node?: ProseMirrorNode; mode?: 'textSize' | 'nodeSize' }) => number\n\n  /**\n   * Get the number of words for the current document.\n   * @param options The options for the character count. (optional)\n   * @param options.node The node to get the words from. Defaults to the current document.\n   */\n  words: (options?: { node?: ProseMirrorNode }) => number\n}\n\n/**\n * This extension allows you to count the characters and words of your document.\n * @see https://tiptap.dev/api/extensions/character-count\n */\nexport const CharacterCount = Extension.create<CharacterCountOptions, CharacterCountStorage>({\n  name: 'characterCount',\n\n  addOptions() {\n    return {\n      limit: null,\n      mode: 'textSize',\n      textCounter: text => text.length,\n      wordCounter: text => text.split(' ').filter(word => word !== '').length,\n    }\n  },\n\n  addStorage() {\n    return {\n      characters: () => 0,\n      words: () => 0,\n    }\n  },\n\n  onBeforeCreate() {\n    this.storage.characters = options => {\n      const node = options?.node || this.editor.state.doc\n      const mode = options?.mode || this.options.mode\n\n      if (mode === 'textSize') {\n        const text = node.textBetween(0, node.content.size, undefined, ' ')\n\n        return this.options.textCounter(text)\n      }\n\n      return node.nodeSize\n    }\n\n    this.storage.words = options => {\n      const node = options?.node || this.editor.state.doc\n      const text = node.textBetween(0, node.content.size, ' ', ' ')\n\n      return this.options.wordCounter(text)\n    }\n  },\n\n  addProseMirrorPlugins() {\n    let initialEvaluationDone = false\n\n    return [\n      new Plugin({\n        key: new PluginKey('characterCount'),\n        appendTransaction: (transactions, oldState, newState) => {\n          if (initialEvaluationDone) {\n            return\n          }\n\n          const limit = this.options.limit\n\n          if (limit === null || limit === undefined || limit === 0) {\n            initialEvaluationDone = true\n            return\n          }\n\n          const initialContentSize = this.storage.characters({ node: newState.doc })\n\n          if (initialContentSize > limit) {\n            const over = initialContentSize - limit\n            const from = 0\n            const to = over\n\n            console.warn(`[CharacterCount] Initial content exceeded limit of ${limit} characters. Content was automatically trimmed.`)\n            const tr = newState.tr.deleteRange(from, to)\n\n            initialEvaluationDone = true\n            return tr\n          }\n\n          initialEvaluationDone = true\n        },\n        filterTransaction: (transaction, state) => {\n          const limit = this.options.limit\n\n          // Nothing has changed or no limit is defined. Ignore it.\n          if (!transaction.docChanged || limit === 0 || limit === null || limit === undefined) {\n            return true\n          }\n\n          const oldSize = this.storage.characters({ node: state.doc })\n          const newSize = this.storage.characters({ node: transaction.doc })\n\n          // Everything is in the limit. Good.\n          if (newSize <= limit) {\n            return true\n          }\n\n          // The limit has already been exceeded but will be reduced.\n          if (oldSize > limit && newSize > limit && newSize <= oldSize) {\n            return true\n          }\n\n          // The limit has already been exceeded and will be increased further.\n          if (oldSize > limit && newSize > limit && newSize > oldSize) {\n            return false\n          }\n\n          const isPaste = transaction.getMeta('paste')\n\n          // Block all exceeding transactions that were not pasted.\n          if (!isPaste) {\n            return false\n          }\n\n          // For pasted content, we try to remove the exceeding content.\n          const pos = transaction.selection.$head.pos\n          const over = newSize - limit\n          const from = pos - over\n          const to = pos\n\n          // It’s probably a bad idea to mutate transactions within `filterTransaction`\n          // but for now this is working fine.\n          transaction.deleteRange(from, to)\n\n          // In some situations, the limit will continue to be exceeded after trimming.\n          // This happens e.g. when truncating within a complex node (e.g. table)\n          // and ProseMirror has to close this node again.\n          // If this is the case, we prevent the transaction completely.\n          const updatedSize = this.storage.characters({ node: transaction.doc })\n\n          if (updatedSize > limit) {\n            return false\n          }\n\n          return true\n        },\n      }),\n    ]\n  },\n})\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}